## Databaseのアンチパターンについて
# 1. 論理削除フラグ（Delete_flg）
  ◆使用目的
    - 誤って削除した情報を基に戻したい
    - 削除した情報も参照したい
    - 画面上は利用者から見え無くしたい　　など
  ◆問題点
    ・実際は、テーブルをJOINする際の条件に都度DELETE_FLGを指定する必要があったり、他のテーブルのマスタが削除されているために
    　表示できなくなると、そのマスタの削除フラグも見る必要がでてきたりといったように、Queryが積み重なり複雑化してしまう。
    ・全てのINDEXのセカンダリにDELETE_FLGを追加する必要も出てきてしまう。
  　・同一ユーザを異なる主キーで登録できてしまうため、外部キー制約ができなくなったり、同一人物のデータが他のテーブルに結び付かなくなってしまう。
    ・目的のレコードを取得するために、関連するDELETE_FLGを持つすべてのテーブルをいちいち参照する必要が出てくるため、
      条件を見逃したり、外部キー制約が効かなくなるなどでバグの温床となる
  ◆解決策
  　- できる限り削除フラグは使用しない
  　- 使用せざるを得ない場合は、有効なレコードのみを表示するViewを参照するようにする
    - PostgreSQLには、メテリアライズドビュー（※）がある
      ※テーブルのデータ自体を保持しているビューなので、ビューへの問い合わせのときよりも、すぐに結果を返すことができる。
        【作成方法】
          CREATE MATERIALIZED VIEW マテリアライズドビュー名 AS （SELECT文);
        【注意点】
          ・作成後そのままにしておくとデータが古くなるため、定期的に最新の状態にする必要がある
            ⇒　REFRESH MATERIALIZED VIEW マテビュー名;
          ・リフレッシュ中にロックがされるため、リフレッシュが終わるまで待たされる
            ⇒　「CONCURRENTLY」オプションをつけることで、テーブル全体をロックすることなくマテリアライズドビューの更新が行える
                REFRESH MATERIALIZED VIEW CONCURRENTLY マテビュー名;
        【使い方】
          マテリアライズドビューにもINDEXを定義することが可能
          CREATE UNIQUE INDEX ON マテビュー名(列1 , 列2 , ・・・);
      ⇒　ただし、更新対象テーブルが増えれば「Reflesh materialized view」の実行回数も増え、パフォーマンス低下
          削除されないデータが増え、更新する際のコストも漸増していく
    - 有効なデータのみを残すために、削除済TABLEを作る
      ⇒　どうしても削除したレコードの情報が必要であれば、削除済TABLEにデータを持たせ、
          不要なら論理削除ではなく物理削除（DELETEクエリ）を行う
  ◆学び
    ・データベースに状態を持たせるのは危ない
      ⇒　データベースには事実のみを保存するようにする

# 2.クエリの最適化
  ◆インデックスが効かなくなるパターン
    ・否定形による比較（<>）
      ⇒　全表検索になる
    ・ORを使用する
      ⇒　ビットマップインデックスであれば効く
    ・IS NULLを使う
      ⇒　強制的に全表検索になる
  　・NULL値を多用する
    　⇒　NULL比較はunknownになるため、比較結果がtrueなのかfalseなのかが分からない。
  　・中間一致や後方一致を使用する
      ⇒　LIKE検索では全表検索となる。前方一致はINDEXが有効。
  ◆解決策
  　・NULLをできるだけ使用しない設計を心掛ける
      ⇒　日付なら「1000/01/01」や「9999/12/31」、文字列なら空文字（※）、数字なら０を入れておく。
          ※データの特性上、空文字に意味があるデータの場合、ダブルミーニングになってしまうため使えない。
    ・IN句やEXISTSなどを使用する
